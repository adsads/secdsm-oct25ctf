<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nonogram Nightmare â€” Responsive</title>
  <style>
    :root{
      --bg1:#0f1724; --bg2:#071032; --accent:#ff6b6b; --accent-2:#ffd93d;
      --cell-size:calc(min(7vmin,40px));
      --gap:4px;
      --clue-size:calc(var(--cell-size) * 0.9);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      background:linear-gradient(180deg,var(--bg1),var(--bg2)); color:#e6eef8; display:flex; flex-direction:column; align-items:center; padding:12px;
    }

    header{width:100%; max-width:1100px; display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom:10px}
    header h1{font-size:1.1rem; margin:0; color:var(--accent)}
    header p{margin:0; opacity:0.9; font-size:0.9rem}

    .game-wrap{width:100%; max-width:1100px; display:flex; gap:12px; flex-direction:column; align-items:center}

    .top-controls{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:center}
    button.btn{background:transparent; border:2px solid var(--accent); color:var(--accent); padding:8px 12px; border-radius:8px; font-weight:600; cursor:pointer}
    button.btn.secondary{border-color:var(--accent-2); color:var(--accent-2)}
    button.btn:active{transform:translateY(1px)}

    .board-area{display:flex; gap:8px; align-items:flex-start; justify-content:center; width:100%; overflow:auto}

    /* clues + grid layout */
    .clue-grid{
      display:grid;
      grid-template-columns: auto 1fr;
      grid-template-rows: auto 1fr;
      gap:8px;
      align-items:start;
    }

    /* column clues row (top-right area) */
    .col-clues{grid-column:2; grid-row:1; display:grid; grid-template-columns:repeat(10, var(--cell-size)); gap:var(--gap); align-items:end; justify-content:start; padding-left:6px}
    .col-clues .col{display:flex; flex-direction:column; gap:4px; align-items:center; justify-content:end}
    .col .c{width:var(--clue-size); height:var(--clue-size); display:flex; align-items:center; justify-content:center; font-weight:700; color:var(--accent-2); background:rgba(255,217,61,0.06); border-radius:6px; border:1px solid rgba(255,217,61,0.12); font-size:0.75rem}

    /* row clues column (left-middle area) */
    .row-clues{grid-column:1; grid-row:2; display:grid; grid-template-rows:repeat(10, var(--cell-size)); gap:var(--gap); padding-top:6px; justify-items:end}
    .row-clues .row{display:flex; gap:6px; align-items:center; justify-content:flex-end}
    .row .r{width:var(--clue-size); height:var(--clue-size); display:flex; align-items:center; justify-content:center; font-weight:700; color:var(--accent-2); background:rgba(255,217,61,0.06); border-radius:6px; border:1px solid rgba(255,217,61,0.12); font-size:0.75rem}

    /* grid */
    .grid-container{grid-column:2; grid-row:2; padding:6px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:12px; border:2px solid rgba(255,107,107,0.08)}
    .grid{
      display:grid; gap:var(--gap); touch-action:none;
      background:transparent; padding:6px;
    }

    .cell{width:var(--cell-size); height:var(--cell-size); display:flex; align-items:center; justify-content:center; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:rgba(255,255,255,0.02); user-select:none}
    .cell.filled{background:var(--accent); border-color:var(--accent)}
    .cell.crossed{background:transparent; position:relative}
    .cell.crossed::after{content:'âœ•'; font-weight:800; color:rgba(255,255,255,0.6); font-size:calc(var(--cell-size) * 0.7)}

    /* stats */
    .stats{display:flex; gap:8px; margin-top:8px; flex-wrap:wrap}
    .stat{background:rgba(255,255,255,0.03); padding:6px 8px; border-radius:8px; min-width:90px; text-align:center}
    .stat b{display:block; color:var(--accent-2); font-size:1rem}

    .flag{display:none; margin-top:12px; background:rgba(255,217,61,0.06); color:var(--accent-2); padding:10px; border-radius:8px; border:2px solid var(--accent-2)}

    /* responsive tweaks */
    @media (max-width:680px){
      :root{--cell-size:calc(min(9vmin,34px))}
      .col-clues{gap:3px}
      .row-clues{gap:3px}
    }

  </style>
</head>
<body>
  <header>
    <div>
      <h1>ðŸŽƒ Nonogram Nightmare</h1>
      <p style="margin-top:6px; opacity:0.85">Tap to fill â€¢ Long-press to mark X â€¢ Works on desktop & mobile</p>
    </div>
    <div class="top-controls">
      <button class="btn" id="toggleMode">Mode: Fill</button>
      <button class="btn secondary" id="checkBtn">Check</button>
      <button class="btn" id="clearBtn">Clear</button>
      <button class="btn" id="hintBtn">Hint</button>
    </div>
  </header>

  <main class="game-wrap">
    <section class="board-area">
      <div class="clue-grid" id="clueGrid">
        <div class="col-clues" id="colClues"></div>
        <div class="row-clues" id="rowClues"></div>
        <div class="grid-container" id="gridContainer">
          <div id="grid" class="grid"></div>
        </div>
      </div>
    </section>

    <div class="stats">
      <div class="stat">Filled <b id="filledCount">0</b></div>
      <div class="stat">Completed Rows <b id="completedRows">0</b></div>
      <div class="stat">Completed Cols <b id="completedCols">0</b></div>
    </div>

    <div class="flag" id="flag">
      <h3>ðŸŽ‰ Solved!</h3>
      <p><strong>Flag:</strong> <code>SecDSM{nonogram_nightmare_2025}</code></p>
    </div>
  </main>

  <script>
    // Responsive nonogram implementation with touch-friendly controls
    const GRID_SIZE = 10;
    let grid = Array.from({length:GRID_SIZE}, ()=>Array(GRID_SIZE).fill(0)); // 0 empty,1 filled,2 crossed
    let gameWon = false;
    let mode = 'fill'; // 'fill' or 'cross' when toggled

    // simple pumpkin solution
    const solution = [
      [0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,1,1,0,0,0,0],
      [0,0,0,1,1,1,1,0,0,0],
      [0,0,1,1,1,1,1,1,0,0],
      [0,0,1,1,1,1,1,1,0,0],
      [0,0,1,1,0,0,1,1,0,0],
      [0,0,0,1,1,1,1,0,0,0],
      [0,0,0,0,1,1,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0]
    ];

    // Save/load
    function saveState(){ localStorage.setItem('nonogram_v2', JSON.stringify({grid,gameWon})); }
    function loadState(){ const s = localStorage.getItem('nonogram_v2'); if(!s) return false; try{ const obj=JSON.parse(s); if(obj.grid) grid=obj.grid; gameWon=!!obj.gameWon; return true }catch(e){return false} }

    // generate clues from solution
    function genClues(sol){
      const rowClues=[]; const colClues=[];
      for(let r=0;r<GRID_SIZE;r++){
        const arr=sol[r];
        const clues=[]; let c=0;
        for(let x=0;x<GRID_SIZE;x++){ if(arr[x]===1) c++; else if(c>0){ clues.push(c); c=0 } }
        if(c>0) clues.push(c);
        rowClues.push(clues.length?clues:[0]);
      }
      for(let col=0;col<GRID_SIZE;col++){
        const clues=[]; let c=0;
        for(let r=0;r<GRID_SIZE;r++){ if(sol[r][col]===1) c++; else if(c>0){ clues.push(c); c=0 } }
        if(c>0) clues.push(c);
        colClues.push(clues.length?clues:[0]);
      }
      return {rowClues,colClues};
    }

    const {rowClues,colClues} = genClues(solution);

    // Create UI
    const gridEl = document.getElementById('grid');
    const colCluesEl = document.getElementById('colClues');
    const rowCluesEl = document.getElementById('rowClues');

    function buildClues(){
      colCluesEl.innerHTML=''; rowCluesEl.innerHTML='';
      // column clues
      for(let c=0;c<GRID_SIZE;c++){
        const wrapper = document.createElement('div'); wrapper.className='col';
        // show from top to bottom (small to large) but want clue bottom-aligned
        const clues = colClues[c];
        const pad = Math.max(0, 3-clues.length);
        for(let i=0;i<pad;i++){ const el=document.createElement('div'); el.className='c'; el.textContent=''; wrapper.appendChild(el) }
        clues.forEach(cl=>{ const el=document.createElement('div'); el.className='c'; el.textContent=cl; wrapper.appendChild(el) })
        colCluesEl.appendChild(wrapper);
      }

      // row clues
      for(let r=0;r<GRID_SIZE;r++){
        const wrapper = document.createElement('div'); wrapper.className='row';
        const clues = rowClues[r];
        const pad = Math.max(0, 3-clues.length);
        for(let i=0;i<pad;i++){ const el=document.createElement('div'); el.className='r'; el.textContent=''; wrapper.appendChild(el) }
        clues.forEach(cl=>{ const el=document.createElement('div'); el.className='r'; el.textContent=cl; wrapper.appendChild(el) })
        rowCluesEl.appendChild(wrapper);
      }
    }

    function buildGrid(){
      gridEl.innerHTML='';
      gridEl.style.gridTemplateColumns = `repeat(${GRID_SIZE}, var(--cell-size))`;
      gridEl.style.gridTemplateRows = `repeat(${GRID_SIZE}, var(--cell-size))`;

      for(let r=0;r<GRID_SIZE;r++){
        for(let c=0;c<GRID_SIZE;c++){
          const cell = document.createElement('div'); cell.className='cell'; cell.dataset.r=r; cell.dataset.c=c; cell.setAttribute('role','button'); cell.setAttribute('aria-label',`row ${r+1} col ${c+1}`)
          updateCellVisual(cell, grid[r][c]);

          // Pointer handling: single tap toggles fill (or in cross mode toggles cross), long press toggles the other
          let pressTimer = null; let moved=false;
          cell.addEventListener('pointerdown', (ev)=>{
            ev.preventDefault(); moved=false; cell.setPointerCapture(ev.pointerId);
            pressTimer = setTimeout(()=>{ // long press -> toggle cross
              toggleCross(r,c); pressTimer=null; saveState(); updateStats();
            }, 450);
          });
          cell.addEventListener('pointermove', ()=>{ moved=true });
          cell.addEventListener('pointerup', (ev)=>{
            ev.preventDefault(); cell.releasePointerCapture(ev.pointerId);
            if(pressTimer){ clearTimeout(pressTimer); pressTimer=null; if(!moved){ // short tap
              if(mode==='fill') toggleFill(r,c); else toggleCross(r,c); saveState(); updateStats(); }
            }
          });
          cell.addEventListener('contextmenu', (e)=>{ e.preventDefault(); toggleCross(r,c); saveState(); updateStats(); });

          gridEl.appendChild(cell);
        }
      }
    }

    function updateCellVisual(cell, state){ cell.classList.remove('filled','crossed'); if(state===1) cell.classList.add('filled'); if(state===2) cell.classList.add('crossed') }
    function toggleFill(r,c){ if(gameWon) return; grid[r][c] = grid[r][c]===1?0:1; // cycle empty->filled->empty
      // clearing cross if filling
      if(grid[r][c]===1) grid[r][c]=1; if(grid[r][c]===1) grid[r][c]=1; updateGridVisualAt(r,c);
    }
    function toggleCross(r,c){ if(gameWon) return; grid[r][c] = grid[r][c]===2?0:2; updateGridVisualAt(r,c); }

    function updateGridVisualAt(r,c){ const cell = gridEl.querySelector(`[data-r='${r}'][data-c='${c}']`); if(cell) updateCellVisual(cell, grid[r][c]); }

    // stats and checks
    function updateStats(){ let filled=0, completedRows=0, completedCols=0; for(let r=0;r<GRID_SIZE;r++){
      let rowCorrect=true; for(let c=0;c<GRID_SIZE;c++){ if(grid[r][c]===1) filled++; if(solution[r][c]===1 && grid[r][c]!==1) rowCorrect=false; if(solution[r][c]===0 && grid[r][c]===1) rowCorrect=false; }
      if(rowCorrect) completedRows++;
    }
    for(let c=0;c<GRID_SIZE;c++){ let colCorrect=true; for(let r=0;r<GRID_SIZE;r++){ if(solution[r][c]===1 && grid[r][c]!==1) colCorrect=false; if(solution[r][c]===0 && grid[r][c]===1) colCorrect=false; } if(colCorrect) completedCols++; }
    document.getElementById('filledCount').textContent = filled; document.getElementById('completedRows').textContent = completedRows; document.getElementById('completedCols').textContent = completedCols;

    if(completedRows===GRID_SIZE && completedCols===GRID_SIZE && filled>0){ winGame(); }
    }

    // Generate flag from solution array
    function generateFlagFromSolution(sol) {
      // Convert solution to a compact string representation
      let flagStr = '';
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          flagStr += sol[r][c];
        }
      }

      // Create a simple hash from the pattern
      let hash = 0;
      for (let i = 0; i < flagStr.length; i++) {
        const char = flagStr.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32-bit integer
      }

      // Convert to positive number and create flag
      const positiveHash = Math.abs(hash);
      return `SecDSM{pumpkin_${positiveHash.toString(16)}}`;
    }

    function winGame(){
      gameWon = true;
      saveState();
      const flagElement = document.getElementById('flag');
      const computedFlag = generateFlagFromSolution(solution);
      flagElement.querySelector('code').textContent = computedFlag;
      flagElement.style.display = 'block';
    }

    function checkSolution(){ // a permissive check: require all filled cells match solution
      let ok=true, filled=0;
      for(let r=0;r<GRID_SIZE;r++){ for(let c=0;c<GRID_SIZE;c++){ if(grid[r][c]===1) filled++; if(grid[r][c]===1 && solution[r][c]!==1) ok=false; if(solution[r][c]===1 && grid[r][c]!==1) ok=false; }}
      if(ok && filled>0) { winGame(); alert('Perfect! You solved the puzzle ðŸŽ‰'); } else { alert('Not correct yet â€” keep trying!') }
      updateStats();
    }

    function clearBoard(){ grid = Array.from({length:GRID_SIZE}, ()=>Array(GRID_SIZE).fill(0)); gameWon=false; document.getElementById('flag').style.display='none'; buildGrid(); saveState(); updateStats(); }

    function showHint(){ // reveal one correct cell that isn't filled yet
      const candidates=[]; for(let r=0;r<GRID_SIZE;r++){ for(let c=0;c<GRID_SIZE;c++){ if(solution[r][c]===1 && grid[r][c]!==1) candidates.push([r,c]); }}
      if(candidates.length===0) return alert('No hints left â€” puzzle looks complete or there are no unrevealed filled cells.'); const [r,c] = candidates[Math.floor(Math.random()*candidates.length)]; grid[r][c]=1; updateGridVisualAt(r,c); saveState(); updateStats(); }

    // wire up buttons
    document.getElementById('toggleMode').addEventListener('click', ()=>{ mode = mode==='fill'?'cross':'fill'; document.getElementById('toggleMode').textContent = `Mode: ${mode==='fill'?'Fill':'Cross'}`; });
    document.getElementById('checkBtn').addEventListener('click', checkSolution);
    document.getElementById('clearBtn').addEventListener('click', ()=>{ if(confirm('Clear the board?')) clearBoard(); });
    document.getElementById('hintBtn').addEventListener('click', showHint);

    // initial load
    loadState(); buildClues(); buildGrid(); // after buildGrid, apply saved visuals
    // apply saved grid visual
    for(let r=0;r<GRID_SIZE;r++){ for(let c=0;c<GRID_SIZE;c++){ updateGridVisualAt(r,c) }}
    updateStats(); if(gameWon) document.getElementById('flag').style.display='block';

    // keyboard accessibility: use arrow keys + space to toggle
    let focusedR=0, focusedC=0;
    window.addEventListener('keydown', (e)=>{
      if(e.key.startsWith('Arrow')){
        if(e.key==='ArrowUp') focusedR = Math.max(0, focusedR-1);
        if(e.key==='ArrowDown') focusedR = Math.min(GRID_SIZE-1, focusedR+1);
        if(e.key==='ArrowLeft') focusedC = Math.max(0, focusedC-1);
        if(e.key==='ArrowRight') focusedC = Math.min(GRID_SIZE-1, focusedC+1);
        const cell = gridEl.querySelector(`[data-r='${focusedR}'][data-c='${focusedC}']`);
        if(cell){ cell.scrollIntoView({block:'nearest', inline:'nearest'}); cell.style.outline='2px solid rgba(255,217,61,0.6)'; setTimeout(()=>cell.style.outline='0',200);
        }
        e.preventDefault();
      }
      if(e.key===' ' || e.key==='Enter'){ // toggle based on mode
        toggleFill(focusedR, focusedC); saveState(); updateStats(); e.preventDefault();
      }
    });

    // prevent accidental zoom double-tap issues on mobile by setting touch-action on grid
  </script>
</body>
</html>
